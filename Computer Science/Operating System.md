# Introduction
- An operating system is a program which acts as an interface between a user and the hardware.
- The primary goal of an operating system is to make the computer system convenient to use and secondary goal is to use computer hardware in an efficient manner.
- An operating system is an important component of a computer system which controls all other components of the computer system.

Major components of a computer system are:
1. Hardware
	- Provides the basic computing resources.
2. Operating System
	- Controls and coordinaters the use of hardware among the various application programs for the various users.
3. Application Program Routines
	- Define the ways in which hardware resources are used to solve the computing problems of the users.
4. Users

There are different types of operating systems available today to cater to varied type of requirements:
- Single User OS
- Multiuser OS
- Time Sharing OS
- Real Time OS
- Multiprocessing OS
- Distributed OS

## OS as a Resource Manager
- A running program or executing entity in the memory is called a process or a job.
- Multiple programs are run interlaced with each other so as to improve the overall efficiency of the computer. 
- Multiprogramming, gets more work done in less time as the CPU may be shared among a number of active programs which are present in the memory at the same time.
- When multiple processes are running simultaneously, it is important to manage them. For this purpose, the OS performs the following functions:
	- Process Management
	- Process Scheduling
	- Memory Management
	- I/O Management

### Process Management
- A process is executed as per its instructions as soon as teh processor or CPU is assigned to it.
- A process is given some memory for each of the following sections for its proper execution:
	- Compiled Code
	- Global Variables
	- Function Calls
	- Local variables (Stack Area)
	- Memory for dynamic memory allocation (Heap area)
- When a program is ready to be executed, it is loaded in memory (start) and becomes an active process.
- An active process passes the following states:
	- Start: Initial state
	- Ready: When the process is ready after wait
	- Running: Process is being executed by the CPU
	- Waiting: The process waiting for some resource.
	- Terminated or Exit: Process is over.

#### How CPU executes the instructions of a ready process:
CPU runs the process, instruction by instruction. CPU executes the instructions of a process by fetching, decoding and then executing it.

1. Program is loaded in main memory
2. Control Unit (CU) brings first (or next) instruction of the program (Fetch the instruction)
3. CU now determines what type of instruction this is. (Decode the instruction)
	- Does it require any mathematical / logical work
	- Or simply read from memory / input device or write to memory / output device, etc.
4A. If the instructions contain mathematical or logical work, CU instructs ALU to carry out the instruction (Execute the Instruction). ALU prodces some results which are stored in the main memory (Store the result).
4B. Or if read from / write to memory, then CU directly instructs the memory, input or output device to carry it out.
5. For the next instruction again instruction 2 to 4 are carried out.

The fetch-decode-execute cycle is also called the instruction cycle.

**Note:** CPU also has some memory registers that temporarily hold data for the CPU. 
### Process Scheduling
Allocation of CPU time to various process in memory is called Process scheduling.

When a program needs to be executed, the process scheduler of the OS loads it into memory and it becomes a process.

It is important to determine:
- Which process will get the CPU time?
- Which process has to be removed from CPU?
- Which process has to be shifted for I/O?
- What is to be the case when **interrupt** occurs
Here, **interrupt** is a signal generated by the hardware or software to the CPU indicating a high priority event that needs immediate attention. In case of an interrupt , the CPU has to interrupt the current running process and handle the interrupt first of all (highest priority)

All this is the job of the process scheduler of the OS. The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.

Since all the loaded processes have to be shared by the CPU, the process scheduler decides upon a strategy (scheduling algorithm) which helps it determine which process will get the CPU time.

Some common scheduling strategies are:
- First Come First Served (FCFS): The process entering first in the queue gets the CPU first.
- Round Robin Scheduling: Every process is given a fixed amount of time on the CPU (called a time slice) say *n* milliseconds. If the process is over during that time, process is terminated; otherwise its state is changed to waiting and the next ready process is given the CPU time for designated amount of time.
- Shortest Job Next: CPU picks the next job that will take shortest time out of all ready processes and many more.

There are many more effiecient scheduling strategies followed by the OS. In short, we can say that processes share the CPU using some time-multiplexing mechanism.

### Memory Management
Memory management has the following functions:
- keeps track of each and every memory location, regardless of whether it is allocated or not.
- checks how much memory is to be allocated to processes and how it will be allocated.
- decides which process will get memory at what time.
- keeps track of whenever some memory gets freed or unallocated and correspondingly it updates the available memory, allocated memory, etc.
- ensures the safety of data in the memory allocated to a process so that other running processes do not get hold of this data.

The memory manager allocates memory to processes to load their data and files etc. using different strategies like contigous memory allocation or non-contigous memory allocation or virtual memory allocation etc. Some common memory management techniques are briefly listed below:
1. Single Memory Allocation: It is the simplest memory management technique in which the available free memory is allocated to single application at a time. This means that only one application runs at a time and other application will get hold of memory only after the running application is over.
2. Partitioned allocation: In this technique, primary memory is divided into different, usually contigous areas of memory called partitions. A running application is allocated one or more partitions depending on its processing requirements
3. Paged Memory Management: In this technique, orimary memory is divided into fixed sized units called page frames or simply pages. A running application is allocated some number of pages for its working depending upon its processing requirements.
4. Segmented Memory Management: in this technique, memory is divided into logical units called segment. Segments may not be contigous in physical memory but logically different chunks of memory may belong to one segment. A running application is allocated some segments depending upon its processing requirements.

#### Virtual Memory
When RAM gets too full, some pack of the hard disk is used as virtual memory / virtual RAM.

To use virtual memory, the OS temporarily marks sections of loaded data in RAM which are less required compared to other loaded sections. These sections are then shifted to virtual memory and RAM is freed.

Virtual Memory is also volatile like RAM.

In order to access data in virtual memory it is first loaded into the RAM and some other less-required section is swapped into virtual memory.
# Language Processors
Special type of computer software that can translate the source code into an object code or machine code.

Source code: refers to the program code written by a programmer in a high level programming language (HLL) such as Java, C, C++, etc.

Object Code: refers to a code usually in machine language or binary code, a language that computer can understand easily and run on hardware.

Therefore, language processors and software that convert source codes into object codes. They are of 3 types:
1. Assembler
	- Converts assembly language into machine language/
2. Interpreter
	- Translates and executes instructions written in a program, line by line, unit by unit etc.
3. Compiler
	- Translates and executes instruction written in a program in one go.

The translated machine code runs fast (faster execution time) as now computer does not require any type of conversion to run it.

Unlike source code which requires conversions into object / machine code before it can be executed.
## Translation Process
### Compiler
- The compiler firsts removes comments from the source code and adds (imports) the required components.
- The compiler now identifies all the individual units (keywords, variables etc.) of the source code and their requirements.
- Using this information, the computer now creates a special kind of table called the symbol table, useful for determining memory requirements.
- The compiler now parses the code and generates the syntax tree, analysing the syntax of the source code.
	- at this point, if the compiler identifies that the syntax and semantic rules of the programming language are violated, it generates an error.
	- At the end of compilation, all the errors found in the source code are listed with line numbers.
- After the code is found to be error-free, the compiler converts it into assembly level instructions.
- The assembly are now converted into object code, which is a form of machine code in a manner similiar to what an assembler does.
- Then, all the required libraries are linked with the object code.
- With the help of the OS, all memory references are resolved and code is converted into a form which requires nothing else to run. i.e. it has every thing in it to execute itself. (compiled code)

### Interpreter
The interpreter analyses one line of code, converts it into object code, adds in required libraries (if any), and then runs it.
Meaning that the first line of code is executed before the second line of code is converted to object code.
In this way it moves line by line.

|Differences|<center>Compiler</center>|<center>Interpreter</center>|
|:---:|---|---|
|**Input**|Entire program|Single line of code|
|**Output**|Intermediate Object Code|No Intermediate object code|
|**Memory**|Requires more memory|Requires less memory|
|**Errors**|Displays list of errors with line number(s) and the error(s) in that line|Displays a **single** error of the instruction it is interpreting|
|**Always Required?**|**No.** Once a compiler has converted code into the executable, it is no longer required to run the file.|**Yes.** Always required in the memory to run the code which is ran one instruction at a time.|


 # Software Libraries
 - Predefined and ready to use suite of data and programming code.
 - The software libarries combine codes / functions / scripts / classes etc. on the basis of their common domain.